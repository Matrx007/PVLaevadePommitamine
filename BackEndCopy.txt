package com.meietiim.pvlaevadepommitamine;

import java.util.Arrays;
import java.util.SplittableRandom;

import static com.meietiim.pvlaevadepommitamine.FrontEnd.*;


/**
 * @author Gregor Suurvarik
 */
public class BackEnd {
    // Makes code shorter because Gregor is lazy
    int playerPlaceShipX = MAIN.playerPlaceShipX;
    int playerPlaceShipY = MAIN.playerPlaceShipY;
    int playerPlaceShipH = MAIN.playerPlaceShipH;
    int playerPlaceShipW = MAIN.playerPlaceShipW;
    int playerPlacedBombX = MAIN.playerPlaceBombX;
    int playerPlacedBombY = MAIN.playerPlaceBombY;

    // AI Data storage
    private boolean AiShipsPlaced = false;
    private int AiPlacedX = 0;
    private int AiPlacedY = 0;
    private int AiPlacedH = 0;
    private int AiPlacedW = 0;
    private int AiBombdX = 0;
    private int AiBombdY = 0;
    private boolean guessingOrientation = false;
    private int orientationAttempt = 0;
    // 1 up -1 down 2 right -2 left 0 not in guessing
    private int[][] AiBombData = new int[10][6];
    // AiBombData stores x y orientation length1 and 2, and if the case exists
    private int bombCase = 0;
    public static final int[] SHIPS = new int[] {5, 4, 3, 3, 2};

    //Random
    private SplittableRandom random = new SplittableRandom();
    public void update() {
        MAIN.response = RESPONSE_EMPTY;
        MAIN.error = ERROR_NONE;
        switch (MAIN.action) {
            case ACTION_PLACE_SHIP: // Player placed a ship
                // Store placed ship in playerShip

                // Check if the ship is placed within the bounds
                boolean correctPlacement = false;
                if(playerPlaceShipX >= 0 && playerPlaceShipY >= 0 &&
                        playerPlaceShipX+playerPlaceShipW-1 < 10 &&
                        playerPlaceShipY+playerPlaceShipH-1 < 10) {
                    correctPlacement = true;
                }

                // Ship is placed correctly, add the changes to board's state
                if(correctPlacement) {
                    // Add the new ship to playerShipData
                    MAIN.playerShipData[MAIN.nextShipID] = new int[] {
                            playerPlaceShipX, playerPlaceShipY,
                            playerPlaceShipW, playerPlaceShipH,
                            0, 0};
                    MAIN.nextShipID++;

                    // Add each piece onto playerShips[][]
                    for(int x = playerPlaceShipX; x < playerPlaceShipX+playerPlaceShipW -1; x++) {
                        for(int y = playerPlaceShipY; y < playerPlaceShipY+playerPlaceShipH -1; y++) {
                            MAIN.playerShips[x][y] = true;
                        }
                    }
                } else {
                    // Ship is placed incorrectly
                    MAIN.error = ERROR_INCORRECT_PLACEMENT;
                }

                break;
            case ACTION_PLACE_BOMB: // Player placed a bomb
                MAIN.playerBombs[playerPlacedBombX][playerPlacedBombY] = true; // Marks bob on the field
                if (MAIN.computerShips[playerPlacedBombX][playerPlacedBombY]){ // If there is a ship
                    MAIN.response = RESPONSE_HIT; // it will sesponse hit
                    // And will add a bomb to ship data
                    MAIN.computerShipData[getShipID(playerPlacedBombX, playerPlacedBombY, MAIN.computerShipData)][4]++;
                    // it will check if ship has sunken
                    if (hasShipSunk(MAIN.computerBombs, MAIN.playerShipData[getShipID(playerPlacedBombX, playerPlacedBombY, MAIN.playerShipData)])){
                        // Marks ship dead
                        MAIN.computerShipData[getShipID(playerPlacedBombX, playerPlacedBombY, MAIN.playerShipData)][5] = 1;
                        // Responds ship dead
                        MAIN.response = RESPONSE_DEAD;
                    }
                }

                break;
            case ACTION_PLACE_COMPUTER: // Computer's turn
                if (AiShipsPlaced) { // If true then ships are placed otherwise place ships
                    // TODO Pommitamine
                    int i = 0; // Variable for while loop
                    int attempts = 0; // To avoid endless loops
                    while (i != 1) { // to be "stuck" here until it has made the move
//#################################################   Advanced AI   ####################################################
                        if (AiBombData[bombCase][5] == 1) { // If that case exists
                            int x = AiBombData[bombCase][0]; // Read X coordinate
                            int y = AiBombData[bombCase][1]; // Read Y coordinate
                            if (guessingOrientation = true){ // If it does not know the orientation
                                if (MAIN.computerBombs[x][y + 1]){
                                    if (MAIN.playerShips[x][y + 1]){
                                        AiBombData[bombCase][2] = 1; // Tell the AI the orientation of the ship
                                        guessingOrientation = false; // We know orientation so we don't have to guess any more
                                    }
                                    else if (MAIN.computerBombs[x][y - 1]){
                                        if (MAIN.playerShips[x][y - 1]){
                                            AiBombData[bombCase][2] = -1;
                                            guessingOrientation = false; // We know orientation so we don't have to guess any more
                                        }
                                    }
                                }
                                else{
                                    if (MAIN.computerBombs[x][y + 1] = false) { // when it hasn't asked that point now it will
                                        MAIN.computerBombs[x][y + 1] = true; // Makes a move
                                        break; // Ends AIs turn
                                    }
                                    else {
                                        if (MAIN.computerBombs[x][y - 1] = false){ // When it hasn't  asked that point it will now
                                            MAIN.computerBombs[x][y - 1] = true; // makes a move
                                            break; // Ends AIs turn
                                        }
                                        else{
                                            AiBombData[bombCase][2] = 2; // When the orientation is not vertical must be horizontal
                                            guessingOrientation = false;
                                        }
                                    }
                                }
                            }
                            //################### End of guessing start of bombing

                        }
//###########################################  End of Advanced AI  ##################################################
                        else {
                            AiBombdX = random.nextInt(10);
                            AiBombdY = random.nextInt(10);
                            attempts++;
                            if (attempts >= 101) {
                            break;
                            }// If something goes wrong it will stop the endless loop
                            if (MAIN.computerBombs[AiBombdX][AiBombdY] != true) { // looks if it has bombed that place
                                MAIN.computerBombs[AiBombdX][AiBombdY] = true; // Marks place to have been bombed
                                if (MAIN.playerShips[AiBombdX][AiBombdY]){ // If there is a player ship
                                    AiBombData[bombCase][0] = AiBombdX; // stores x and y from the last hit for next move
                                    AiBombData[bombCase][1] = AiBombdY;
                                    guessingOrientation = true;
                                    MAIN.response = RESPONSE_HIT; // Responds Hit
                                    // finds the ship and increases the bomb count
                                    MAIN.playerShipData[getShipID(AiBombdX, AiBombdY, MAIN.playerShipData)][4]++;
                                    // Checks if ship has sunken
                                    if (hasShipSunk(MAIN.computerBombs, MAIN.playerShipData[getShipID(AiBombdX, AiBombdY, MAIN.playerShipData)])){
                                        // Marks ship dead
                                        MAIN.playerShipData[getShipID(AiBombdX, AiBombdY, MAIN.playerShipData)][5] = 1;
                                        //Responds "Ship is down on the ocean floor"
                                        MAIN.response = RESPONSE_DEAD;
                                    }
                                }
                                i++; // One of the conditsions for this loop, so that AI has to make a move and retry if it failed
                            }
                        }
                    }
                }
                else {
                    int i = 0;
                    while (i < MAIN.computerShipData.length) {
                        if (MAIN.computerShipData[i][3] == 0){
                            // AI places ships
                            // Gets X and Y for that ship to fit inn the area
                            if (random.nextBoolean()) { // If true ship will be placed horizontally
                                                        // Otherwise ship will be placed vertically
                                AiPlacedX = random.nextInt(10 - SHIPS[i]);
                                AiPlacedY = random.nextInt(10);
                                AiPlacedH = 1;
                                AiPlacedW = SHIPS[i];
                            }
                            else {
                                AiPlacedX = random.nextInt(10);
                                AiPlacedY = random.nextInt(10 - SHIPS[i]);
                                AiPlacedH = SHIPS[i];
                                AiPlacedW = 1;
                            }
                            // Check if ship fits
                            if (MAIN.isSpaceFree(AiPlacedX, AiPlacedY, AiPlacedW, AiPlacedH, MAIN.computerShips)){
                                for(int x = AiPlacedX; x <= AiPlacedX + AiPlacedW - 1; x++) {
                                    for(int y = AiPlacedY; y <= AiPlacedY + AiPlacedH - 1; y++) {
                                        MAIN.computerShips[x][y] = true;
                                    }
                                } // Adds ships to computerShipData
                                MAIN.computerShipData[i] = new int[] {AiPlacedX, AiPlacedY,
                                        AiPlacedW, AiPlacedH, 0, 0};
                                i++; // tells to to next ship
                            }
                            //If all ships are placed it marks placing ships done
                            if (i == 5) {AiShipsPlaced = true;}
                        }
                        else { // If ship exists then moves to another ship
                            i++;
                        }
                    }
                }
                break;
        }
    }
    /**
     * @return Returns a ship that contains given point. If
     *         not found, -1 will be returned.
     */
    public int getShipID(int checkX, int checkY, int[][] shipData) {

        // Iterates thru all the ships
        for(int i = 0; i < shipData.length; i++) {

            // If the given point lies in the boundaries of that ship
            // return the ship's ID.
            if(checkX >= shipData[i][0] &&
                    checkY >= shipData[i][1] &&
                    checkX < shipData[i][0]+shipData[i][2] &&
                    checkY < shipData[i][1]+shipData[i][3]) {
                return i;
            }
        }

        // If none of the ships contained the point, return -1
        return -1;
    }

/**
 *
 *
 * @return Returns a ship that contains given point. If
 *         not found, -1 will be returned.
 */
    public boolean hasShipSunk(boolean[][] bombs, int[] targetShipData) {

        // Bomb counter
        int foundBombs = 0;

        // Iterate thru each point in the ship and count all the bombs in it
        for(int i = targetShipData[0]; i < targetShipData[0]+targetShipData[2]; i++) {
            for(int j = targetShipData[1]; j < targetShipData[1]+targetShipData[3]; j++) {
                if(bombs[i][j]) {
                    foundBombs++;
                }
            }
        }

        // If the number of found bombs on the ship is equal with the
        // length of the ship, the ship has sunk
        return foundBombs == Math.max(targetShipData[2], targetShipData[3]);
    }
}